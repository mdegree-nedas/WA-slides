\section*{computational complexity}
\addcontentsline{toc}{section}{computational complexity}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: problema in computer science}
\addcontentsline{toc}{subsection}{def: problema in computer science}
\begin{flushleft}
	un problema $\pi$ \'e una relazione
	$$\pi\subseteq I_{\pi}\times S_{\pi}$$
	dove:
	\begin{itemize}
		\item $I_{\pi}=$ insieme delle istanze di input del problema
		\item $S_{\pi}=$ insieme delle soluzioni del problema
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{tipologie di problema}
\addcontentsline{toc}{subsection}{tipologie di problema}
\begin{flushleft}
	\begin{itemize}
		\item \textbf{decisione:}
			\begin{itemize}
				\item si verifica se una data propriet\'a \'e valida per un determinato input
				\item $S_{\pi}=\{true,false\}$ o semplicemente $S_{\pi}=\{0,1\}$ e la relazione $\pi\subseteq I_{\pi}\times S_{\pi}$ corrisponde ad una funzione $$f:I_{\pi}\rightarrow\{0,1\}$$ 
				\item esempi: soddisfacibilit\'a, test di connettivit\'a di un grafo, etc....
			\end{itemize}
		\item \textbf{ricerca:}
		\begin{itemize}
			\item data un'istanza $x\in I_{\pi}$, si chiede di determinare una soluzione $y\in S_{\pi}$ tale che la coppia $(x,y)\in\pi$ appartengono alla relazione che definisce il problema
			\item esempi: soddisfacibilit\'a, clique, vertex cover, nei quali chiediamo in output un assegnamento di verit\'a soddisfacente, rispettivamente una clique o un vertex cover, invece di semplicemente "si" o "no"
		\end{itemize}
		\item \textbf{ottimizzazione}
		\begin{itemize}
			\item data un'istanza $x\in I_{\pi}$, si chiede di determinare una soluzione $y\in S_{\pi}$ ottimizzando una data misura della funzione costo
			\item esempi: min spanning tree, max SAT, max clique, min vertex cover, min TSP, etc....
		\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{complessit\'a degli algoritmi e dei problemi}
\addcontentsline{toc}{subsection}{complessit\'a degli algoritmi e dei problemi}
\begin{flushleft}
	\begin{itemize}
		\item espressa in funzione della taglia dell'input (denotata come $|x|, \forall x\in I_{\pi}$)
		\item taglia dell'istanza $x$
		\begin{itemize}
			\item quantit\'a di memoria necessaria a memorizzare $x$ in un computer
			\item lunghezza $|x|_{c}$ della stringa che codifica $x$ in un particolare codice naturale $c:I_{\pi}\rightarrow\Sigma$, dove $\Sigma$ \'e l'alfabeto del codice $c$
		\end{itemize}
		\item codice naturale
		\begin{itemize}
			\item conciso: le stringhe che codificano le istanze non devono essere ridondanti o allungate inutilmente
			\item numeri espressi in base $\geq 2$
		\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{esempio: codice}
\addcontentsline{toc}{subsection}{esempio: codice}
\begin{flushleft}
	\begin{itemize}
		\item istanza: grafo $G$
	\end{itemize}
\end{flushleft}
\begin{center}
\begin{tikzpicture}
	\Vertex[fontsize=\normalsize, x=0, y=0, label=1, opacity=0]{1}
	\Vertex[fontsize=\normalsize, x=3, y=0, label=2, opacity=0]{2}
	\Vertex[fontsize=\normalsize, x=0, y=-3, label=3, opacity=0]{3}
	\Vertex[fontsize=\normalsize, x=3, y=-3, label=4, opacity=0]{4}
	\Edge[fontsize=\normalsize, position=above, label=2](1)(2)
	\Edge[fontsize=\normalsize, position=left, label=1](1)(3)
	\Edge[fontsize=\normalsize, position=right, label=7](2)(4)
	\Edge[fontsize=\normalsize, position=below, label=4](3)(4)
	\Edge[fontsize=\normalsize, position={above left}, label=3](3)(2)
\end{tikzpicture}
\end{center}
\begin{flushleft}
	\begin{itemize}
		\item codice per $G$
		\begin{itemize}
			\item $\Sigma=\{\{,\},,,0,1,2,3,4,5,6,7,8,9\}$ (simboli)
			\item $c(G)=\{1,2,3,4,\{1,2\},\{1,3\},\{2,3\},\{2,4\},\{3,4\},2,1,3,7,4\}$
			\begin{itemize}
				\item $\{1,2,3,4\}$ (nodi)
				\item $\{\{1,2\},\{1,3\},\{2,3\},\{2,4\},\{3,4\}\}$ (archi)
				\item $\{2,1,3,7,4\}$ (pesi)
			\end{itemize}
			\item $|G|_{c}=49$
		\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: tempo di esecuzione dell'algoritmo $A$}
\addcontentsline{toc}{subsection}{def: tempo di esecuzione dell'algoritmo $A$}
\begin{flushleft}
	sia $t_{A}(x)$ il tempo di esecuzione dell'algoritmo $A$ per l'input $x$, allora il tempo di esecuzione nel caso peggiore di $A$ \'e: $$T_{A}(n)=\max\{t_{A}(x)\hspace{0.1cm}|\hspace{0.1cm}|x|\leq n\},\hspace{0.5cm}\forall n>0$$
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: complessit\'a temporale dell'algoritmo $A$}
\addcontentsline{toc}{subsection}{def: complessit\'a temporale dell'algoritmo $A$}
\begin{flushleft}
	l'algoritmo $A$ ha complessit\'a temporale
	\begin{itemize}
		\item $O(g(n))$ se $T_{A}(n)=O(g(n))$, ovvero $$\lim_{n\to\infty}\frac{T_{A}(n)}{g(n)}\leq c\text{, per una costante }c>0$$
		\item $\Omega(g(n))$ se $T_{A}(n)=\Omega(g(n))$, ovvero $$\lim_{n\to\infty}\frac{T_{A}(n)}{g(n)}\geq c\text{, per una costante }c>0$$
		\item $\Theta(g(n))$ se $T_{A}(n)=\Theta(g(n))$, ovvero $$T_{A}(n)=\Omega(g(n))\text{ e }T_{A}(n)=O(g(n))$$
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: complessit\'a di un problema}
\addcontentsline{toc}{subsection}{def: complessit\'a di un problema}
\begin{flushleft}
	un problema ha complessit\'a
	\begin{itemize}
		\item $O(g(n))$ se esiste un algoritmo che lo risolve avente complessit\'a $O(g(n))$
		\item $\Omega(g(n))$ se ogni algoritmo $A$ che lo risolve ha complessit\'a $\Omega(g(n))$
		\item $\Theta(g(n))$ se ha complessit\'a $O(g(n))$ e $\Omega(g(n))$
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{problemi di decisione e classi di complessit\'a}
\addcontentsline{toc}{subsection}{problemi di decisione e classi di complessit\'a}
\begin{flushleft}
	i problemi di decisione sono solitamente descritti da un'istanza di input (o semplicemente INPUT) e da una DOMANDA sull'input \newline \\
	esempi:
	\begin{itemize}
		\item soddisfacibilit\'a
			\begin{itemize}
				\item INPUT: CNF (Conjunctive Normal Form) formula definita su un insieme di variabili
				\item DOMANDA: esiste un assegnamento di verit\'a $\tau:V\rightarrow\{0,1\}$ ?
			\end{itemize}
		\item clique
			\begin{itemize}
				\item INPUT: un grafo non orientato $G=(V,E)$ di $n$ nodi e un intero $k>0$
				\item DOMANDA: esiste in $G$ una clique di almeno $k$ nodi ($\geq k$), ovvero un sottoinsieme $U\subseteq V$ tale che $|U|\geq k$ e $\{u,v\}\in E,\hspace{0.1cm}\forall u,v\in U$ ?
			\end{itemize}
		\item vertex cover
			\begin{itemize}
				\item INPUT: un grafo non orientato $G=(V,E)$ di $n$ nodi e un intero $k>0$
				\item DOMANDA: esiste in $G$ un vertex cover di al massimo $k$ nodi ($\leq k$), ovvero un sottoinsieme $U\subseteq V$ tale che $|U|\leq k$ e $u\in U$ o $v\in U$, $\forall\{u,v\}\in E$ ?
			\end{itemize}
	\end{itemize}
	nei problemi di decisione $I_{\pi}=Y_{\pi}\cup N_{\pi}$
	\begin{itemize}
		\item $Y_{\pi}=$ insieme di istanze positive, ovvero con soluzione $1$
		\item $N_{\pi}=$ insieme di istanze negative, ovvero con soluzione $0$
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: un algoritmo $A$ risolve $\pi$}
\addcontentsline{toc}{subsection}{def: un algoritmo $A$ risolve $\pi$}
\begin{flushleft}
	un algoritmo $A$ risolve $\pi\iff\forall$ input $x\in I_{\pi}$, $A$ risponde $1\iff x\in Y_{\pi}$
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: classe dei problemi $TIME(g(n))$}
\addcontentsline{toc}{subsection}{def: classe dei problemi $TIME(g(n))$}
\begin{flushleft}
	$TIME(g(n))=$ classe dei problemi di decisione con complessit\'a $O(g(n))$
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{algoritmi non-deterministici per i problemi di decisione}
\addcontentsline{toc}{subsection}{algoritmi non-deterministici per i problemi di decisione}
\begin{flushleft}
	essi si compongono di 2 fasi
	\begin{itemize}
		\item fase 1
		\begin{itemize}
			\item generano in modo non-deterministico un "certificato" $y$
		\end{itemize}
		\item fase 2
		\begin{itemize}
			\item partendo dall'input $x$ e dal certificato $y$, verificano se $x$ \'e un'istanza positiva
		\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: un algoritmo non-deterministico $A$ risolve $\pi$}
\addcontentsline{toc}{subsection}{def: un algoritmo non-deterministico $A$ risolve $\pi$}
\begin{flushleft}
	un algoritmo non-deterministico $A$ risolve $\pi$ se si ferma per ogni possibile certificato $y$ ed esiste un certificato $y$ per cui $A$ risponde $1$ ($true$) $\iff x\in Y_{\pi}$
	\begin{itemize}
		\item complessit\'a
		\begin{itemize}
			\item costo della fase 2
			\item espressa in funzione di $|x|$
		\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: classe dei problemi $NTIME(g(n))$}
\addcontentsline{toc}{subsection}{def: classe dei problemi $NTIME(g(n))$}
\begin{flushleft}
	$NTIME(g(n))=$ classe di problemi di decisione con complessit\'a non-deterministica $O(g(n))$
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{esempio: algoritmo non-deterministico per il problema della clique}
\addcontentsline{toc}{subsection}{esempio: algoritmo non-deterministico per il problema della clique}
\begin{flushleft}
	\begin{itemize}
		\item fase 1
		\begin{itemize}
			\item dato in input il grafo $G=(V,E)$, genera non-deterministicamente un sottoinsieme $U\subseteq V$ di $k$ nodi
		\end{itemize}
		\item fase 2
		\begin{itemize}
			\item verifica se $U$ \'e una clique, ovvero se $\{u,v\}\in E,\hspace{0.1cm}\forall u,v\in U$, e in tal caso risponde $1$, altrimenti risponde $0$
		\end{itemize}
	\item chiaramente l'algoritmo risolve il problema della clique, in quanto si ferma per ogni possibile sottoinsieme $U$ ed esiste un sottoinsieme $U$ per il quale risponde $1$ se e solo se esiste una clique di $k$ nodi in $G$, ovvero $\iff(G,k)\in Y_{clique}$
	\item complessit\'a: $O(n^2)$, poich\'e $|U|\leq|V|=n$
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{osservazioni (algoritmi deterministici e non-deterministici)}
\addcontentsline{toc}{subsection}{osservazioni (algoritmi deterministici e non-deterministici)}
\begin{flushleft}
	\begin{itemize}
		\item un algoritmo deterministico \'e meno potente di uno non-deterministico poich\'e non pu\'o eseguire la fase 1
		\item se esiste un algoritmo deterministico $A$ che risolve $\pi$, allora esiste anche un algoritmo non-deterministico $A'$ che risolve $\pi$ con la stessa complessit\'a come segue:
			\begin{itemize}
				\item esso esegue al fase 1 e coincide con $A$ nella fase 2, ignorando il certificato $y$
			\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{corollario: $TIME(g(n))\subseteq NTIME(g(n))$}
\addcontentsline{toc}{subsection}{corollario: $TIME(g(n))\subseteq NTIME(g(n))$}
\begin{flushleft}
	$$TIME(g(n))\subseteq NTIME(g(n))$$
	\begin{itemize}
		\item dove:
		\begin{itemize}
			\item $TIME(g(n))=$ classe dei problemi deterministicamente risolvibili in tempo $O(g(n))$
			\item $NTIME(g(n))=$ classe dei problemi non-deterministicamente risolvibili in tempo $O(g(n))$
		\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{efficienza e trattabilit\'a}
\addcontentsline{toc}{subsection}{efficienza e trattabilit\'a}
\begin{flushleft}
	\begin{itemize}
		\item un problema \'e trattabile se pu\'o essere risolto efficientemente (deterministicamente)
		\item sono considerati trattabili o efficientemente risolvibili tutti i problemi aventi complessit\'a limitata da un polinomio della dimensione dell'input
	\end{itemize}
	$$\text{TRATTABILIT\'A}\equiv\text{EFFICIENZA}\equiv\text{POLINOMIALIT\'A}$$
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{efficienza e trattabilit\'a: ragione 1}
\addcontentsline{toc}{subsection}{efficienza e trattabilit\'a: ragione 1}
\begin{flushleft}
	la crescita delle funzioni polinomiali rispetto a quelle esponenziali (sia per ci\'o che riguarda il tempo di esecuzione sia per ci\'o che riguarda la dimensione delle istanze risolvibili entro un certo tempo di esecuzione)
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{efficienza e trattabilit\'a: ragione 2}
\addcontentsline{toc}{subsection}{efficienza e trattabilit\'a: ragione 2}
\begin{flushleft}
	\begin{itemize}
		\item la composizione di polinomi \'e un polinomio e dunque la risolvibilit\'a in tempo polinomiale di un problema \'e indipendente da
		\begin{itemize}
			\item il codice naturale utilizzato, poich\'e tutti i codici naturali sono correlati in maniera polinomiale
			\item il modello computazionale adottato, se ragionevole (cio\'e costruibile nella pratica o meglio in grado di eseguire un lavoro limitato costante per step), in quanto tali modelli sono polinomialmente correlati, ovvero possono simularsi l'un l'altro in tempo polinomiale
		\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{osservazione: macchina di turing non-deterministica}
\addcontentsline{toc}{subsection}{osservazione: macchina di turing non-deterministica}
\begin{flushleft}
	la macchina di turing non-deterministica non \'e un modello di calcolo ragionevole, poich\'e la quantit\'a di lavoro svolto in ogni fase (ciascun livello dell'albero delle computazioni) cresce in modo esponenziale
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: codici polinomialmente correlati}
\addcontentsline{toc}{subsection}{def: codici polinomialmente correlati}
\begin{flushleft}
	\begin{itemize}
		\item 2 codici $c_1$ e $c_2$ per un problema $\pi$ sono correlati polinomialmente se esistono 2 polinomi $p_1$ e $p_2$ tali che, $\forall x\in I_{\pi}$:
		\begin{itemize}
			\item $|x|_{c_1}\leq p_1(|x|_{c_2})$
			\item $|x|_{c_2}\leq p_2(|x|_{c_1})$
		\end{itemize}
	\item se la complessit\'a rispetto a $c_1$ \'e $O(q_1(|x|_{c_1}))$ per un dato polinomio $q_1$, allora rispetto a $c_2$ \'e $O(q_1(p_1(|x|_{c_2})))=O(q_2(|x|_{c_2}))$ dove $q_2$ \'e il polinomio tale che $\forall\lambda\hspace{0.1cm}q_2(\lambda)=q_1(p_1(\lambda))$
	\item tutti i codici naturali sono correlati polinomialmente, ovvero la risolvibilit\'a polinomiale non dipende dal particolare codice utilizzato
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{dimensione dell'input (def: codici correlati polinomialmente)}
\addcontentsline{toc}{subsection}{dimensione dell'input (def: codici correlati polinomialmente)}
\begin{flushleft}
	qualsiasi quantit\'a polinomialmente correlata ad un codice naturale \'e dunque correlata ad un qualsiasi codice naturale possibile, dato che tutti i codici naturali sono correlati polinomialmente e che la composizione di polinomi \'e un polinomio
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{esempio: codici correlati polinomialmente}
\addcontentsline{toc}{subsection}{esempio: codici correlati polinomialmente}
\begin{flushleft}
	\begin{itemize}
		\item assumiamo che per ogni grafo $G$ di $n$ nodi
		\begin{itemize}
			\item $|G|_{c_1}=10n^2$
			\item $|G|_{c_2}=n^3$
		\end{itemize}
		\item se $p_1(\lambda)=10\lambda$ e $p_2(\lambda)=\lambda^2$ abbiamo che:
		\begin{itemize}
			\item $|G|_{c_1}=10n^2\leq 10n^3=p_1(|G|_{c_2})$
			\item $|G|_{c_2}=n^3\leq 100n^4=p_2(|G|_{c_1})$
		\end{itemize}
		\item dunque i 2 codici sono correlati polinomialmente
		\vspace{1cm}
		\item regola pratica:
		\begin{itemize}
			\item 2 quantit\'a sono polinomialmente correlate se sono polinomi sulle stesse variabili
		\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{esempio: codifica non naturale}
\addcontentsline{toc}{subsection}{esempio: codifica non naturale}
\begin{flushleft}
	\begin{itemize}
		\item test di primalit\'a
		\begin{itemize}
			\item INPUT: un numero intero $n>0$ 
			\item DOMANDA: $n$ \'e un numero primo?
			\item ALGORITMO (banale):
			\begin{itemize}
				\item scansiona tutti i numeri da $2$ a $n-1$ e risponde $1$ ($true$) se nessuno di essi lo divide
			\end{itemize}
			\item COMPLESSIT\'A: $O(n)$, polinomiale?
			\item CODICE $c_1$ (naturale): $n$ espresso in base $2$, ovvero $|n|_{c_1}=\log_2{n}$
			\item CODICE $c_2$ (non naturale): $n$ espresso in base $1$, ovvero $|n|_{c_2}=n$
		\end{itemize}
		\item dunque la complessit\'a dell'algoritmo \'e:
		\begin{itemize}
			\item $O(2^{|n|_{c_1}})$ rispetto a $c_1$, che \'e esponenziale
			\item $O(|n|_{c_2})$ rispetto a $c_2$, che \'e polinomiale!
		\end{itemize}
		\item dimensione dell'input
			\begin{itemize}
				\item correlata polinomialmente ai codici naturali $|n|_{c_1}=\log_2{n}$
			\end{itemize}
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{def: modelli computazionali simulabili in modo polinomiale}
\addcontentsline{toc}{subsection}{def: modelli computazionali simulabili in modo polinomiale}
\begin{flushleft}
	\begin{itemize}
		\item 2 modelli computazionali $M_1$ e $M_2$ sono mutualmente simulabili in modo polinomiale se esistono 2 polinomi $p_1$ a $p_2$ tali che:
		\begin{enumerate}
			\item ogni algoritmo  $A$ per $M_1$ con complessit\'a $T_A(n)$ pu\'o essere simulato su $M_2$ in tempo $p_1(T_A(n))$
			\item ogni algoritmo  $A$ per $M_2$ con complessit\'a $T_A(n)$ pu\'o essere simulato su $M_1$ in tempo $p_2(T_A(n))$
		\end{enumerate}
		\item dunque se $A$ \'e polinomiale in $M_1$ allora \'e polinomiale anche in $M_2$ e viceversa
		\item tutti i modelli computazionali ragionevoli sono mutualmente simulabili in modo polinomiale, ovvero la risolvibilit\'a polinomiale non dipende dal particolare modello utilizzato
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{classi $P$ e $NP$}
\addcontentsline{toc}{subsection}{classi $P$ e $NP$}
\begin{flushleft}
	\begin{itemize}
		\item $P=$ classe di tutti i problemi risolvibili deterministicamente in tempo polinomiale, ovvero
			$$P=\cup_{k=0}^{\infty}TIME(n^k)$$
		\item $NP=$ classe di tutti i problemi risolvibili non-deterministicamente in tempo polinomiale, ovvero
			$$NP=\cup_{k=0}^{\infty}NTIME(n^k)$$
		\item $P=NP$ ? nessuno lo a dimostrato
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\subsection*{problemi $NP$-completi}
\addcontentsline{toc}{subsection}{problemi $NP$-completi}
\begin{flushleft}
	\begin{itemize}
		\item i problemi pi\'u difficili di $NP$ e tali che se $P\neq NP$ non appartengono a $P$, viceversa, se 1 di essi appartiene a $P$, allora $P=NP$
		\item finora nessuno \'e riuscito a trovare un algoritmo polinomiale deterministico per nessun problema $NP$-completo
		\item congettura: $P\neq NP$
	\end{itemize}
\end{flushleft}

% $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\newpage
